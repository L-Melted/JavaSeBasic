package cn.lm.demo.继承抽象;

public class Zi extends Fu {

    //zi中的成员变量
    int num = 6;

    public void show() {

        //访问父类中的num
        System.out.println("Fu num=" + super.num);
        //访问子类中的num
        System.out.println("Zi num=" + this.num);
    }


    /**
     * 子父类中出现了同名的成员变量时，
     * 在子类中需要访问父类中非私有成员变量时，需要使用super 关键字，修饰父类成员变量，
     * 类似于之前学过的 this ,this是访问本类中的成员变量。
     *
     * 变量的调用遵循就近原则：局部 < 本类的成员 < 父类的成员
     *
     * Fu 类中的成员变量是非私有的，子类中可以直接访问。
     * 若Fu 类中的成员变量私有了，子类是不能直接访问的。
     * 通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？
     * 对！可以在父类中提供公共的getXxx方法和setXxx方法。
     *
     *
     *
     * 如果子类父类中出现重名的成员方法，这时的访问是一种特殊情况，叫做方法重写 (Override)。
     *
     * - 方法重写 ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。
     * - 特点:  声明不变，重新实现。
     *
     *
     * 注意事项
     *
     * 1. 子类方法覆盖父类方法，必须要保证子类方权限大于等于父类方法权限。
     *    (public > protected >  (default)  > private)
     * 2. 子类方法覆盖父类方法，返回值类型要跟父类的返回值==一样或者是其子类==
     *    一般来讲，直接保证父子类中的声明一样（返回值类型一样，权限修饰符一样）
     *
     *
     *在继承关系中的特点:
     * 1. 构造方法不继承:  构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。
     * 2. 构造对象时父类实例优先初始化:  构造方法的作用是初始化成员变量的,
     *                                在创建子类对象的时候会先初始化父类的成员表量,（在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。）
     *                                后初始化子类的成员变量.
     *                                在代码中的表现是当执行子类构造方法后,
     *                                子类构造方法一定会首先调用父类构造方法 ( 请使用Debug进行调试验证下)
     *
     * 在使用this和super访问构造方法时特别要注意:
     *
     * 1. 子类的每个构造方法中均有默认的super( )，调用父类的空参构造。
     * 2. super( ) 和 this( ) 都必须是在构造方法的第一行，所以不能同时出现.
     * 3. 手动显式调用父类构造会覆盖默认的super( )。
     *
     *
     *
     * Java仅支持单继承，不支持多继承；支持多层继承
     *
     *
     *
     * 抽象（抽象类和抽象方法）
     * 1. 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。
     * 2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。
     * 3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
     * 4. 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。
     * 5. 抽象方法一定不能是静态方法  【静态一定时具体的】
     * */
}
